import React from 'react';
import ReactDOM from 'react-dom';
import t from 'tcomb';
import { props } from 'tcomb-react';
import { DragSource, DropTarget } from 'react-dnd';

// from example https://github.com/gaearon/react-dnd/blob/master/examples/04 Sortable/Simple/Card.js
const columnTarget = {
  canDrop(props) {
    return !props.fixed;
  },
  drop(props) {
    props.onReorderEnd();
  },
  hover(props, monitor, component) {
    if (!monitor.canDrop()) {
      return;
    }

    const dragItem = monitor.getItem();
    const dragIndex = dragItem.index;
    const { name, index } = props;
    const hoverItem = { name, index };
    const hoverIndex = index;

    // Don't replace items with themselves
    if (dragIndex === hoverIndex) {
      return;
    }

    // Determine rectangle on screen
    const hoverBoundingRect = ReactDOM.findDOMNode(component).getBoundingClientRect();

    // Get horizontal middle
    const hoverMiddleX = (hoverBoundingRect.right - hoverBoundingRect.left) / 2;

    // Determine mouse position
    const clientOffset = monitor.getClientOffset();

    // Get pixels to the left
    const hoverClientX = clientOffset.x - hoverBoundingRect.left;

    // Only perform the move when the mouse has crossed half of the items width
    // When dragging leftwards, only move when the cursor is below 50%
    // When dragging rightwards, only move when the cursor is above 50%

    // Dragging rightwards
    if (dragIndex < hoverIndex && hoverClientX < hoverMiddleX) {
      return;
    }

    // Dragging leftwards
    if (dragIndex > hoverIndex && hoverClientX > hoverMiddleX) {
      return;
    }

    // Time to actually perform the action
    props.onReorder(dragItem, hoverItem);

    monitor.getItem().index = hoverItem.index;
  }
};

const columnSource = {
  beginDrag(props) {
    // Return the data describing the dragged item
    const item = {
      name: props.name,
      index: props.index
    };
    return item;
  },
  isDragging(props, monitor) {
    return props.name === monitor.getItem().name;
  },
  canDrag(props) {
    return !props.fixed;
  }
};

const connect = (connect, monitor) => ({
  connectDragSource: connect.dragSource(),
  isDragging: monitor && monitor.isDragging()
});

@DropTarget('Column', columnTarget, (connect, monitor) => ({
  connectDropTarget: connect.dropTarget(),
  isOver: monitor.isOver(),
  isOverCurrent: monitor.isOver({ shallow: true }),
  canDrop: monitor.canDrop(),
  itemType: monitor.getItemType()
}))
@DragSource('Column', columnSource, connect)
@props({
  children: t.ReactChildren,
  name: t.String,
  index: t.maybe(t.Number),
  className: t.maybe(t.String),
  fixed: t.maybe(t.Boolean),
  // drag source props
  itemType: t.maybe(t.String),
  isDragging: t.Boolean,
  connectDragSource: t.Function,
  // drop target props
  canDrop: t.maybe(t.Boolean),
  isOver: t.maybe(t.Boolean),
  isOverCurrent: t.maybe(t.Boolean),
  connectDropTarget: t.Function,
  onReorder: t.maybe(t.Function),
  onReorderEnd: t.maybe(t.Function)
})
export default class ColumnHeader extends React.Component {

  static defaultProps = {
    fixed: false
  };

  render() {
    const {
      connectDragSource,
      connectDropTarget,
      children
    } = this.props;

    // note: `transorm: translate3d(0,0,0)` on wrapping div seems to solve defects with react-dnd dragging preview
    return connectDragSource(connectDropTarget(<div style={{ transform: 'translate3d(0,0,0)' }}>{children}</div>));
  }
}
