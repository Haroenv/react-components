import React from 'react';
import ReactDOM from 'react-dom';
import cx from 'classnames';
import t from 'tcomb';
import { props } from 'tcomb-react';
import { pure } from 'revenge';
import { Column, ColumnGroup } from 'fixed-data-table';
import Table, { checkPropsInvariants } from '../TableWrapper/TableWrapper';
import FlexView from '../FlexView/FlexView';
import TextOverflow from '../TextOverflow/TextOverflow';
import Icon from '../Icon/Icon';
import sortBy from 'lodash/sortBy';
import every from 'lodash/every';
import groupBy from 'lodash/groupBy';
import findIndex from 'lodash/findIndex';
import find from 'lodash/find';
import isEqual from 'lodash/isEqual';
import { DragDropContext } from 'react-dnd';
import HTML5Backend from 'react-dnd-html5-backend';
import ColumnHeader from './Column/ColumnHeader';

import './grid.scss';

const filterPerGroup = (columnGroup) => (column) =>
  (column.columnGroup === columnGroup) ||
  (typeof column.columnGroup === 'undefined' && columnGroup === '');

const checkColumnsGroups = ({ columns }) => {
  const columnGroups = Object.keys(groupBy(columns, 'columnGroup')).map( label => typeof label === 'undefined' ? '' : label);
  const thereAreGroups = columnGroups.filter( label => label !== '' ).length > 0;
  const allColumnGroupsHaveColumnsOrAllFixedOrNoneOfThem = every(columnGroups.map(group => columns.filter(filterPerGroup(group)).map(c => c.fixed).every((x, i, _columns) => x === _columns[0]) ) );
  const isValid = !thereAreGroups || allColumnGroupsHaveColumnsOrAllFixedOrNoneOfThem;
  if (!isValid) {
    console.warn('If you use fixed columns and columnGroups, all columns that belong to the same group should have the same value for `fixed`'); //eslint-disable-line no-console
  }
  return isValid;
};

const columnKey = c => c.key;
const columnWidth = c => c.width;
const columnsEqual = (columnsA, columnsB) => {
  const columnsAKeys = columnsA.map(columnKey);
  const columnsBKeys = columnsB.map(columnKey);
  const columnsAWidths = columnsA.map(columnWidth);
  const columnsBWidths = columnsB.map(columnWidth);
  return isEqual(columnsAKeys, columnsBKeys) && isEqual(columnsAWidths, columnsBWidths);
}

@DragDropContext(HTML5Backend)
@pure
@props(t.subtype(t.struct({
  data: t.Arr,
  height: t.maybe(t.Num),
  width: t.maybe(t.Num),
  rowHeight: t.maybe(t.Num),
  headerHeight: t.maybe(t.Num),
  footerHeight: t.maybe(t.Num),
  columnWidth: t.maybe(t.Num),
  cellRenderer: t.maybe(t.Func),
  headerRenderer: t.maybe(t.Func),
  footerRenderer: t.maybe(t.Func),
  scrollToRow: t.maybe(t.Num),
  sort: t.maybe(t.struct({
    stateless: t.maybe(t.Boolean),
    by: t.maybe(t.Str),
    dir: t.maybe(t.enums.of(['asc', 'desc'], 'sortDir')),
    onChange: t.maybe(t.Func)
  })),
  columns: t.maybe(t.list(t.struct({
    columnGroup: t.maybe(t.Str),
    key: t.String,
    label: t.String,
    width: t.maybe(t.Num),
    fixed: t.maybe(t.Bool),
    sortable: t.maybe(t.Bool),
    resizable: t.maybe(t.Boolean)
  }))),
  autoSizeColumns: t.maybe(t.Bool),
  onColumnResizeEndCallback: t.maybe(t.Func),
  isColumnResizing: t.maybe(t.Bool),
  autoSize: t.maybe(t.Bool),
  className: t.maybe(t.Str),
  selectedRows: t.maybe(t.list(t.Num)),
  onRowSelect: t.maybe(t.Func),
  onRowsSelect: t.maybe(t.Func),
  onRowRightClick: t.maybe(t.Function),
  selectionType: t.enums.of(['none', 'single', 'multi'], 'selectionType'),
  bindShortcuts: t.maybe(t.Boolean),
  onColumnsOrderChange: t.maybe(t.Function),
  autoAdjustLastColumnWidth: t.maybe(t.Boolean)
}), (props) => checkColumnsGroups(props) && checkPropsInvariants(props), 'GridProps'))
export default class Grid extends React.Component {

  state = {
    columns: this.props.columns,
    selectedColumns: [],
    selectedRows: this.props.selectedRows,
    filteredColumns: [],
    gridWidth: 0
  };

  static defaultProps = {
    height: 500,
    width: 250,
    rowHeight: 30,
    columnWidth: 50,
    headerHeight: 35,
    footerHeight: 0,
    cellRenderer: cellData => cellData,
    footerRenderer: () => {},
    scrollToRow: 0,
    autoSize: true,
    className: '',
    onColumnResizeEndCallback: () => {},
    isColumnResizing: false,
    selectionType: 'single',
    onRowRightClick: () => {},
    selectedRows: []
  };

  componentDidMount() {
    this.setGridWidth();
  }

  componentWillReceiveProps(newProps) {
    const maybeNewSelectedRows = !t.Nil.is(newProps.selectedRows[0]) ? { selectedRows: newProps.selectedRows } : {};
    const maybeNewColumns = !this.state.reorderingColumns && !columnsEqual(newProps.columns, this.state.columns) ? {
      columns: newProps.columns
    } : {};
    this.setState({
      ...maybeNewColumns,
      ...maybeNewSelectedRows
    });
  }

  componentDidUpdate() {
    this.setGridWidth();
  }

  setGridWidth = () => {
    if (this.props.autoAdjustLastColumnWidth) {
      const gridWidth = ReactDOM.findDOMNode(this).offsetWidth;
      if (this.state.gridWidth !== gridWidth) {
        this.setState({ gridWidth });
      }
    }
  }

  onColumnSelect = (key) => {
    this.setState({
      selectedColumns: [key]
    });
  }

  onRowSelect = (index) => {
    this.setState({
      selectedRows: [index]
    });
  }

  sortColumns = (dragItem, dropTarget) => {
    const { columns } = this.state;
    const dragColumn = find(columns, { key: dragItem.name });
    const sortedColumns = columns.slice(0);
    sortedColumns.splice(dragItem.index, 1);
    sortedColumns.splice(dropTarget.index, 0, dragColumn);
    return sortedColumns;
  }

  onColumnReorder = (dragItem, hoverTarget) => {
    this.setState({
      columns: this.sortColumns(dragItem, hoverTarget),
      reorderingColumns: true
    });
  }

  onColumnReorderEnd = () => {
    const { onColumnsOrderChange } = this.props;
    this.setState({ reorderingColumns: false });
    onColumnsOrderChange && onColumnsOrderChange(this.state.columns);
  }

  cellRenderer = (selectedRows) => (cellData, selected, cellDataKey, rowData, rowIndex) => {
    const cursorOnRow = selectedRows.indexOf(rowIndex) !== -1;
    const cursorOnColumn = this.state.selectedColumns.indexOf(cellDataKey) !== -1;
    return (
      <div
        className={cx('grid-cell', { selected, cursorOnRow, cursorOnColumn })}
        style={{ height: this.props.rowHeight }}
        onContextMenu={e => this.props.onRowRightClick(e, cellData, selected, cellDataKey, rowData)}
      >
        {this.props.cellRenderer(cellData, selected, cellDataKey, rowData)}
      </div>
    );
  }

  onHeaderClick = (key) => () => {
    if (!this.props.sort) {
      return;
    }

    const prevSortDir = key === this.props.sort.by ? this.props.sort.dir : undefined;
    const sortDir = (() => {
      switch (prevSortDir) {
        case 'asc': return 'desc';
        case 'desc': return undefined;
        default: return 'asc';
      }
    })();
    const sortBy = sortDir ? key : undefined;
    const onSortChange = this.props.sort.onChange;

    onSortChange && onSortChange({ sortBy, sortDir });
  };

  defaultHeaderRenderer = ({ sortDir }) => (label, key, columnData, rowData, width) => {
    const column = find(this.state.columns, { key });
    const sortable = !!this.props.sort && column && column.sortable !== false;
    const cursorOnColumn = this.state.selectedColumns.indexOf(key) !== -1;
    const headerClassName = cx('grid-header', { sortable, cursorOnColumn });
    const icon = sortDir === 'asc' ? 'sort-asc' : sortDir === 'desc' ? 'sort-desc' : 'sort';
    return (
      <FlexView grow onClick={sortable ? this.onHeaderClick(key) : () => {}} className={headerClassName} style={{ width }} basis={`${width}px`} vAlignContent='center'>
        <FlexView grow style={{ position: 'relative' }} vAlignContent='center'>
          <FlexView column grow vAlignContent='center'>
            <TextOverflow label={label} />
          </FlexView>
          {sortable && (
            <FlexView className='icon-wrapper' vAlignContent='center'>
              <Icon icon={icon} />
            </FlexView>
          )}
        </FlexView>
      </FlexView>
    );
  };

  headerRenderer = ({ by: sortBy, dir: sortDir }) => (label, cellDataKey, columnData, rowData, width) => {
    const translatedLabel = label;
    const columnIndex = findIndex(this.state.columns, { key: cellDataKey });
    const column = this.state.columns[columnIndex];

    const columnHeaderProps = {
      key: columnIndex,
      name: cellDataKey,
      index: columnIndex,
      fixed: column.fixed,
      onReorder: this.onColumnReorder,
      onReorderEnd: this.onColumnReorderEnd
    };

    return (
      <ColumnHeader {...columnHeaderProps}>
        {this.props.headerRenderer ?
          this.props.headerRenderer(translatedLabel, cellDataKey, columnData, rowData, width)
        : this.defaultHeaderRenderer({
          sortBy: sortBy === cellDataKey,
          sortDir: sortBy === cellDataKey && sortDir
        })(translatedLabel, cellDataKey, columnData, rowData, width)}
      </ColumnHeader>
    );
  };

  headerRendererColumnGroups = ({ by: sortBy, dir: sortDir }) => (label, cellDataKey, columnData, rowData, width) => {
    const translatedLabel = label;

    const columnHeaderProps = {
      key: cellDataKey,
      name: `${cellDataKey}`,
      fixed: true
    };

    return (
      <ColumnHeader {...columnHeaderProps}>
        {this.props.headerRenderer ?
          this.props.headerRenderer(translatedLabel, cellDataKey, columnData, rowData, width)
        : this.defaultHeaderRenderer({
          sortBy: sortBy === cellDataKey,
          sortDir: sortBy === cellDataKey && sortDir
        })(translatedLabel, cellDataKey, columnData, rowData, width)}
      </ColumnHeader>
    );
  };

  footerRenderer = (label, cellDataKey, columnData, rowData, width) => {
    return this.props.footerRenderer(label, cellDataKey, columnData, rowData, width);
  };

  columnsTemplate = (columns) => ({ columnWidth, ...columnProps }) => columns.map(({ key: dataKey, label, fixed, width, resizable = true }) => (
    <Column {...{
      width: width || columnWidth,
      key: dataKey,
      dataKey,
      fixed,
      label,
      isResizable: resizable,
      ...columnProps
    }}
    />
  ));

  autoAdjustLastColumnWidth = (columns, gridWidth) => {
    const columnsLength = columns.length;
    const lastColumn = columns[columnsLength - 1];
    const columnsApartFromLast = columns.slice(0, columnsLength - 1);

    const totalWidth = columnsApartFromLast.reduce((_totalWidth, _column) => _totalWidth + _column.width, 0);
    return columnsApartFromLast.concat({
      ...lastColumn,
      width: (totalWidth < gridWidth) ? (gridWidth - totalWidth) : lastColumn.width
    });
  }

  render() {
    const {
      cellRenderer,
      footerRenderer,
      onColumnSelect,
      onRowSelect: internalRowSelect,
      state: {
        selectedColumns,
        selectedRows: _selectedRows,
        columns: _columns,
        gridWidth
      },
      props: {
        sort,
        height, width,
        className,
        autoSizeColumns, autoSize,
        bindShortcuts,
        selectionType, onRowSelect: _onRowSelect, onRowsSelect: _onRowsSelect,
        rowHeight, columnWidth, headerHeight, footerHeight,
        onColumnResizeEndCallback, autoAdjustLastColumnWidth
      }
    } = this;

    const columns = autoAdjustLastColumnWidth ?
      this.autoAdjustLastColumnWidth(_columns, gridWidth)
      : _columns;
    const _data = this.props.data.map((d, index) => ({ ...d, originalIndex: index }));
    const data = (sort && !sort.stateless) ? (sort.dir === 'asc' ? sortBy(_data, sort.by) : sortBy(_data, sort.by).reverse()) : _data.slice(0);
    const rowGetter = index => data[index];
    const rowsCount = data.length;

    const selectedRows = _selectedRows.map(originalIndex => findIndex(data, { originalIndex }));
    const onRowSelect = selectionType === 'single' ?
      index => _onRowSelect(data[index].originalIndex) :
      index => internalRowSelect(data[index].originalIndex);
    const onRowsSelect = selectionType === 'multi' ? (indexes) => _onRowsSelect(indexes.map(index => data[index].originalIndex)) : null;

    const columnGroups = Object.keys(groupBy(columns, 'columnGroup')).map( label => label !== 'undefined' ? label : '' );
    const thereAreGroups = columnGroups.filter( label => label !== '' ).length > 0;
    const groupHeaderHeight = thereAreGroups ? headerHeight : null;

    const propsSort = this.props.sort || {};
    const headerRenderer = columnGroups[0] !== '' ? this.headerRendererColumnGroups(propsSort) : this.headerRenderer(propsSort);

    const tableProps = {
      selectedColumns, onColumnSelect, columns,
      className: cx('grid', className),
      autoSizeColumns, autoSize,
      selectionType, selectedRows, onRowSelect, onRowsSelect,
      height, width,
      rowGetter, rowsCount,
      cellRenderer: cellRenderer(selectedRows),
      rowHeight, headerHeight, footerHeight, groupHeaderHeight,
      bindShortcuts,
      onColumnResizeEndCallback: (width, key) => { onColumnResizeEndCallback(parseInt(width), key); },
      isColumnResizing: false
    };

    const columnProps = {
      columnWidth,
      cellRenderer, footerRenderer, headerRenderer, allowCellsRecycling: true
    };

    return (
      <Table {...tableProps}>
        {thereAreGroups ? columnGroups.map(columnGroup => (
          <ColumnGroup
            label={columnGroup}
            key={columnGroup}
            fixed={columns.filter(filterPerGroup(columnGroup))[0].fixed}
            groupHeaderRenderer={columnProps.headerRenderer}
          >
            {this.columnsTemplate(columns.filter(filterPerGroup(columnGroup)))(columnProps)}
          </ColumnGroup>
        )) :
          this.columnsTemplate(columns)(columnProps)
        }
      </Table>
    );
  }
}
